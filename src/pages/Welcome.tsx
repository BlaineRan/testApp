import { PageContainer } from '@ant-design/pro-components';
import { Alert, Card, Typography } from 'antd';
import React from 'react';
import styles from './Welcome.less';
const { Title, Paragraph, Text, Link } = Typography;

const blockContent = `AntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、不限可能的数据可视化最佳实践。得益于丰富的业务场景和用户需求挑战，AntV 经历多年积累与不断打磨，已支撑整个阿里集团内外 20000+ 业务系统，通过了日均千万级 UV 产品的严苛考验。
我们正在基础图表，图分析，图编辑，地理空间可视化，智能可视化等各个可视化的领域耕耘，欢迎同路人一起前行。`;

const CodePreview: React.FC = ({ children }) => (
  <pre className={styles.pre}>
    <code>
      <Typography.Text copyable>{children}</Typography.Text>
    </code>
  </pre>
);

const Welcome: React.FC = () => {

  return (
    <PageContainer>
      <Card>
        <Alert
          message="您已登录成功！从左侧菜单栏开始查看或管理桥梁信息！"
          type="success"
          showIcon
          banner
          style={{
            margin: -12,
            marginBottom: 24,
          }}
        />
        <Typography.Text strong>

        </Typography.Text>

        <Typography>
          <Title>写在最前面</Title>
          <Paragraph>
            本项目最初作为本学期程序设计实践2的课设项目，整个系统从前端到后端到数据库均为本人(632002060214周文浩)一人完成<br />
            整个项目功能相对十分完善，但由于本项目后端以java为基础，通过SSM(Spring SpringMVC MyBatis)架构，
            难以将后端程序部分托管至github pages。故为了完整展示页面，我阉割了登录以及权限管理功能(事实上你可以在已注释的代码中看到这部分功能，
            它们大多集中在login.tsx、access.ts中) <br />
            此外，本项目大部分涉及数据库操作的功能也难以完整展现，接口失效的情况下本项目中几乎所有http请求都会失败(地图部分除外，但它也
            因无法获得桥梁数据而失去几乎所有功能) <br /> <br />
            但我仍然认为这对于一个大二学生来说是一个不错的项目，在学期最后一周我几乎所有时间都在这个项目上面，答辩前还通宵了两天，
            付出了相当的精力。前后端中都有我认为还算精彩的设计，java的后端源代码我也会放在这个另一个仓库里<br />
            <Link href="https://github.com/BlaineRan/testApp/tree/master">前端仓库</Link><br />
            <Link href="https://github.com/BlaineRan/briddge">后端仓库</Link>


          </Paragraph>

          <Title level={2}>《通信软件开发与应用》课程结业报告</Title>
          <Title level={3}>介绍</Title>
          <Paragraph>
            本项目前端部分整体以react和umi为基础，结合ant design组件库完成开发 <br /><br />

            完整的已实现的稳定功能有: <br />
            <ul>
              <li>
                <Text strong>不定参数数量的分页查询</Text><br />
                ----系统会在登录时对接口进行一次初始访问，进行size为20的基础查询。用户每次翻页或点击查询都会对这个接口进行不同参数的调用
                值得一提的是系统会根据不同的参数数量(查询条件)向后端发送不同结构的请求参数，相当程度地方便了后端开发(虽然也是我自己) <br />
                完成查询后，通过<Text strong>react原生的状态管理</Text>在会话周期(整个页面的生命周期)内保存当次查询结果，直到用户退出或进行下一次查询时才会变更。
                该数据会供给之后的地图和检查功能"消费"，减少了后端接口调用。<br />
                用户"桥梁地图"后页面会开始加载地图(由<Link href="https://lbs.amap.com/">高德地图API</Link>支持)，根据已查询到的桥梁信息在地图对应位置添加覆盖物以展示位置。
              </li>
              <li>
                <Text strong>桥梁信息增删改</Text><br />
                ----这部分的后端部分十分简单，但前端部分就是一个涉及到交互设计的复杂问题。首先考虑到添加和修改一般都只针对单个数据，
                但删除很可能需要批量删除。为此我为桥梁信息展示设计了多选功能，仍然依靠<Text strong>react原生的状态管理</Text>实现，通过一个数组状态来记录当前选择的数据列key，选择后桥梁信息组件中可隐藏的footer会显示出来，展示已显示的数据条数和一个删除按钮，整体交互体感还算不错
                <br />
                对于新增和更新，它们几乎在本质上是一样的操作，给后端传送的数据结构也一模一样，因此它们都是通过点击一个按钮弹出表单的方式来实现的(更新按钮位于每行数据的最后，没数据显示不出来)。此处更新和新增在交互上由一点小不同，新增弹窗的表单初始值都是空的，但对于更新弹窗更符合直觉的做法是使初始值是对应的数据列的信息，
                这需要按钮为弹窗传递当前列的数据(因为所有列的弹窗实质上是同一个组件)，这里取巧用了ant design已封装好的方法来获取当前列信息
              </li>
              <li>
                <Text strong>检查功能</Text><br />
                ----桥梁日常检查的业务流程相对来说并不复杂，但却有一个复杂的数据结构。为了满足复杂且自由度较高的数据录入，本功能采用的是可以点击新增表单项的表单。用于复杂数据的录入。由于每个桥梁有多个检查记录，用户可以点击任意一个桥梁数据来在右表显示它的所有检查记录。同样这也采用了分页查询。<br />
                定期检查拥有更复杂的数据结构和业务流程，前后端都有不小的难度，这里只说前端。由于每个桥都分为桥面系、上部结构、下部结构三部分，而每个桥每个部分的检查内容和检查标准都完全不一样，甚至每个桥拥有的上部结构和下部结构数量都不一样，这就对表单的设计提出了很高要求。我通过设计分步表单引导用户
                按部分录入数据，且根据桥的数据向后端请求对应的检查标准，结构化生成不同的表单。上下部结构则给出了对应的桥跨桥墩列表，每个数据后都给一个按钮用以录入数据，且通过useEffect这个hook使桥墩桥跨中最后一个数据项为响应式的(类似vue中的钩子)，使其能表示对应数据是否登记完毕。总的来说是一个对表单设计要求很高的功能
              </li>
            </ul>



          </Paragraph>
          <Paragraph>
            虽然有些功能无法展示，但源代码中都还留有它们的影子，由于不影响系统运行，甚至大部分代码都没有注释掉(事实上只有登录功能被注掉大部分，因为它阻碍了主组件的显示)。如果有兴趣可以浅读一下源码，甚至对照前端的package.json和后端的pom.xml搭建环境复现项目。
          </Paragraph>
          <Title level={3}>遇到的问题</Title>
          <Paragraph>
            尽管项目规模不大，但由于业务场景十分复杂(<Text strong>见王家伟老师发给我们的200页圣经《城市桥梁养护技术标准》</Text>)，无论是前端还是后端都碰到了大量的问题，这里挑其中几个有意思的前端小问题说一下<br />
            <ul>
              <li>
                由于是前后端分离项目，最早遇到的问题是前后端跨域请求的问题，跨域访问需要在后端有特殊的设置，解决了这个问题后又引申出session和cookie数据获取不到的问题，后端无论如何拿到的cookie都取不到数据，这个问题让权限管理几乎无法实现
              </li>
              <li>
                解决了上述问题后，权限管理的难点来到了前端。为了在全局管理用户信息和权限，设置路由权限的同时还需要能全局用同样的方式获取当前用户信息。全局信息在umi中有initalState这样的解决方案，但请求本身要如何保证呢？
                <br />(当然这个问题根本原因是我奇怪的强迫症，其实多写几个不同的request就能简单地解决)
              </li>
              <li>
                react的jsx/tsx语法不允许在html中插入流程控制语句，比如if-else,for,while等，这导致想要进行像vue一样的条件渲染就只能使用原生html和js(vue中常使用v-if和v-for)。jsx/tsx只允许插入js/ts表达式，又没有办法能用表达式来达到和流程控制一样的效果呢？
              </li>
              <li>
                react在不同级的组件外部(尤其是函数组件)强制组件重新渲染是有点麻烦的，但这个操作偏偏又大量地用到了，有没有办法可以用简短的的办法使指定组件在状态变化时每次都重新渲染呢？
              </li>
            </ul>
          </Paragraph>

          <Title level={3}>如何解决</Title>
          <Paragraph>
            <ul>
              <li>
                前后端跨域问题在后端对于ssm项目来说只需要在每个controller顶层加上@CrossOrigin注解即可。对于cookie数据取不到的问题，进行多次debug后发现问题出在前端，每次前端发回来的cookie都不一样，这是因为跨域协议使得前端每次请求都是一个新的会话，解决方法也很简单，使用axios请求的项目直接设置withCredentials: true即可
              </li>
              <li>
                umi的initialState不仅可以保存普通数据，所以我将对当前用户的请求函数也作为一个可选属性存储，每次使用的时候getInitalState获取即可，甚至可以在不同组件自定义这个请求函数
              </li>
              <li>
                可以选择插入逻辑运算符。<br />
                <pre>
                  假如我们需要写这样的功能: <br />
                  if(currentUser != null){"{"}<br />
                  return 组件1
                  <br />
                  {"}"} <br />
                  在jsx/tsx中可以写成<br />
                  currentUser && 组件 <br />
                  这样当currentUser为null时，编译器就直接跳过了后面的判断，如果currentUser不为null，编译器就会渲染组件1
                </pre>
              </li>
              <li>
                可以给该组件指定一个随机的不重复key<br />
                react中key是唯一指定一个组件的属性，所以如果key发生变化，react就会重新渲染这个组件，比如<br />
                <pre>
                  key = 123 + new Date() <br />
                </pre>
                这样就会将Date对象转换成对应的字符串赋值给key，key一定不会重复，可以达到高频重新渲染的目的<br /><br />
              </li>
            </ul>
            实际遇到的问题远不止这些，这里仅挑几个印象较深的前端问题分享
          </Paragraph>
          <Title level={3}>没解决的问题</Title>
          <Paragraph>
            没解决的问题主要集中在后端层面，前端只能说确实做的不够完美，但大部分想法我都知道怎么实现，差的只是时间，比如点击地图位置来新建桥梁、新增任务派发功能、系统内修改用户权限等等。
            这次的前端更大的问题还是耗时过长，是我对react的一次不太愉快的尝试，也有我自己太久不做前端的原因，下次会做的更好。
          </Paragraph>


          <Title level={3}>总结</Title>
          <Paragraph>
            这次项目给我带来的成长还是很多的，全栈开发的经历更坚定了我对未来的规划。作为对react和ant design的第一次尝试，这次不能算的上愉快，遇到了很多在vue上从没想过的小问题(react的响应式处理经常把我搞晕)。但react仍然给了我
            很多惊喜，比vue更不方便换来的是更灵活的开发体验，我几乎没想到完全做不了的功能，只需要考虑"麻不麻烦"而不是"我会不会"。它的设计思路也与vue有很多不同，而且react极其强大而完备的生态圈让我不禁感慨现在中台前端开发的门槛
            是真的低，那么多现成的解决方案开箱即用。<br />
            前端学习是一个很漫长的过程，越往后学习越能体会到前端这个方向的深度一点不比后端差。这次积累的开发经验相信很快就会给我带来惊喜，我会继续加深我的学习。
          </Paragraph>
        </Typography>
      </Card >
    </PageContainer >
  );
};

export default Welcome;
